<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>Proxy - scala.reactive.Signal.Proxy</title>
          <meta name="description" content="Proxy - scala.reactive.Signal.Proxy" />
          <meta name="keywords" content="Proxy scala.reactive.Signal.Proxy" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript">
         if(top === self) {
            var url = '../../index.html';
            var hash = 'scala.reactive.Signal$$Proxy';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img src="../../lib/trait_big.png" />
        <p id="owner"><a href="../package.html" class="extype" name="scala">scala</a>.<a href="package.html" class="extype" name="scala.reactive">reactive</a>.<a href="Signal$.html" class="extype" name="scala.reactive.Signal">Signal</a></p>
        <h1>Proxy</h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <span class="name">Proxy</span><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>A proxy that emits events from the underlying signal
 and has the same value as the underlying signal.
</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>the type of the proxy signal
</p></dd></dl><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>], <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>], <a href="../package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a>, <span class="extype" name="scala.Any">Any</span></div>
        </div><div class="toggleContainer block">
          <span class="toggle">Known Subclasses</span>
          <div class="subClasses hiddenContent"><a href="container/ReactContainer$$Aggregate.html" class="extype" name="scala.reactive.container.ReactContainer.Aggregate">Aggregate</a></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="scala.reactive.Signal.Proxy"><span>Proxy</span></li><li class="in" name="scala.reactive.Signal"><span>Signal</span></li><li class="in" name="scala.reactive.Reactive"><span>Reactive</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
                <span class="filtertype">Implicitly<br />
                </span>
                <ol id="implicits"> <li class="in" name="scala.reactive.Reactive.ReactiveOps" data-hidden="false"><span>by ReactiveOps</span></li><li class="in" name="scala.reactive.Signal.SignalOps" data-hidden="false"><span>by SignalOps</span></li><li class="in" name="scala.reactive.Signal.SignalOps" data-hidden="false"><span>by SignalOps</span></li><li class="in" name="scala.Predef.any2stringadd" data-hidden="true"><span>by any2stringadd</span></li><li class="in" name="scala.Predef.any2stringfmt" data-hidden="true"><span>by any2stringfmt</span></li><li class="in" name="scala.Predef.any2ArrowAssoc" data-hidden="true"><span>by any2ArrowAssoc</span></li><li class="in" name="scala.Predef.any2Ensuring" data-hidden="true"><span>by any2Ensuring</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        

        <div id="values" class="values members">
              <h3>Abstract Value Members</h3>
              <ol><li name="scala.reactive.Signal.Proxy#proxy" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="proxy:scala.reactive.Signal[T]"></a>
      <a id="proxy:Signal[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">proxy</span><span class="result">: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>
      </span>
      </h4>
      
    </li></ol>
            </div>

        <div id="values" class="values members">
              <h3>Concrete Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:AnyRef):Boolean"></a>
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <a href="../package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Predef.any2stringadd#+" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="+(other:String):String"></a>
      <a id="+(String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $plus" class="implicit">+</span><span class="params">(<span name="other">other: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <span class="extype" name="scala.runtime.StringAdd">StringAdd</span> performed by method any2stringadd in scala.Predef.
            
          </dd><dt>Definition Classes</dt><dd>StringAdd</dd></dl></div>
    </li><li name="scala.Predef.any2ArrowAssoc#-&gt;" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="-&gt;[B](y:B):(A,B)"></a>
      <a id="-&gt;[B](B):(Proxy[T],B)"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $minus$greater" class="implicit">-&gt;</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span class="extype" name="scala.Predef.ArrowAssoc.-&gt;.B">B</span></span>)</span><span class="result">: (<a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>], <span class="extype" name="scala.Predef.ArrowAssoc.-&gt;.B">B</span>)</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <span class="extype" name="scala.Predef.ArrowAssoc">ArrowAssoc</span>[<a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]] performed by method any2ArrowAssoc in scala.Predef.
            
          </dd><dt>Definition Classes</dt><dd>ArrowAssoc</dd><dt>Annotations</dt><dd>
                <span class="name">@inline</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:AnyRef):Boolean"></a>
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <a href="../package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.reactive.Reactive#after" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="after[S](that:scala.reactive.Reactive[S]):scala.reactive.Reactive[T]withscala.reactive.Reactive.Subscription"></a>
      <a id="after[S](Reactive[S]):Reactive[T]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">after</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="that">that: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Reactive.after.S">S</span>]</span>)</span><span class="result">: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a new reactive value that produces events from <code>this</code> reactive value
 only after <code>that</code> produces an event.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new reactive value that produces events from <code>this</code> reactive value
 only after <code>that</code> produces an event.</p><p> After <code>that</code> emits some event, all events from <code>this</code> are produced on the resulting reactive.
 If <code>that</code> unreacts before an event is produced on <code>this</code>, the resulting reactive unreacts.
 If <code>this</code> unreacts, the resulting reactive unreacts.
</p></div><dl class="paramcmts block"><dt class="tparam">S</dt><dd class="cmt"><p>the type of <code>that</code> reactive</p></dd><dt class="param">that</dt><dd class="cmt"><p>the reactive after whose first event the result can start propagating events</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription and the resulting reactive that emits only after <code>that</code> emits
                    at least once.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd></dl></div>
    </li><li name="scala.reactive.Signal.Proxy#apply" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="apply():T"></a>
      <a id="apply():T"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">apply</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.reactive.Signal.Proxy.T">T</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the last event produced by <code>this</code> signal.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the last event produced by <code>this</code> signal.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the signal's value
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a> → <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.reactive.Reactive.ReactiveOps#asSignal" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asSignal:scala.reactive.Reactive.ReactiveOps[T]withscala.reactive.Signal[T]"></a>
      <a id="asSignal:ReactiveOps[T]withSignal[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">asSignal</span><span class="result">: <a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] with <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Downcasts this reactive into a signal.</p><div class="fullcomment"><div class="comment cmt"><p>Downcasts this reactive into a signal.</p><p> Throws an exception if the current reactive is not a signal.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the signal version of the current reactive
</p></dd></dl><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] performed by method ReactiveOps in <a href="Reactive$.html" class="extype" name="scala.reactive.Reactive">scala.reactive.Reactive</a>.
            
          </dd><dt>Definition Classes</dt><dd><a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a></dd></dl></div>
    </li><li name="scala.reactive.Reactive.ReactiveOps#asSignalOrElse" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asSignalOrElse(init:T):scala.reactive.Signal[T]"></a>
      <a id="asSignalOrElse(T):Signal[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">asSignalOrElse</span><span class="params">(<span name="init">init: <span class="extype" name="scala.reactive.Signal.Proxy.T">T</span></span>)</span><span class="result">: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">If the current reactive is a signal already this method downcasts it,
 otherwise it lifts it into a signal with the initial value <code>init</code>.</p><div class="fullcomment"><div class="comment cmt"><p>If the current reactive is a signal already this method downcasts it,
 otherwise it lifts it into a signal with the initial value <code>init</code>.
</p></div><dl class="paramcmts block"><dt class="param">init</dt><dd class="cmt"><p>optional value to use when converting the reactive to a signal</p></dd><dt>returns</dt><dd class="cmt"><p>the signal version of the current reactive
</p></dd></dl><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] performed by method ReactiveOps in <a href="Reactive$.html" class="extype" name="scala.reactive.Reactive">scala.reactive.Reactive</a>.
            
          </dd><dt>Definition Classes</dt><dd><a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a></dd></dl></div>
    </li><li name="scala.reactive.Signal#changes" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="changes:scala.reactive.Signal[T]withscala.reactive.Reactive.Subscription"></a>
      <a id="changes:Signal[T]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">changes</span><span class="result">: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">A signal that only emits events when the value of <code>this</code> signal changes.</p><div class="fullcomment"><div class="comment cmt"><p>A signal that only emits events when the value of <code>this</code> signal changes.</p><pre>time    ---------------&gt;
<span class="kw">this</span>    --<span class="num">1</span>---<span class="num">2</span>--<span class="num">2</span>--<span class="num">3</span>--&gt;
changes --<span class="num">1</span>---<span class="num">2</span>-----<span class="num">3</span>--&gt;</pre></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a subscription and the signal with changes of <code>this</code>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a></dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <a href="../package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.reactive.Reactive#collect" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="collect[S&lt;:AnyRef](pf:PartialFunction[T,S])(implicitevidence:&lt;:&lt;[T,AnyRef]):scala.reactive.Reactive[S]withscala.reactive.Reactive.Subscription"></a>
      <a id="collect[S&lt;:AnyRef](PartialFunction[T,S])(&lt;:&lt;[T,AnyRef]):Reactive[S]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collect</span><span class="tparams">[<span name="S">S &lt;: <a href="../package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a></span>]</span><span class="params">(<span name="pf">pf: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>, <span class="extype" name="scala.reactive.Reactive.collect.S">S</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="evidence">evidence: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>, <a href="../package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a>]</span>)</span><span class="result">: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Reactive.collect.S">S</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Filters events from <code>this</code> reactive and maps them in the same time.</p><div class="fullcomment"><div class="comment cmt"><p>Filters events from <code>this</code> reactive and maps them in the same time.</p><p> The <code>collect</code> combinator uses a partial function <code>pf</code> to filter events
 from <code>this</code> reactive. Events for which the partial function is defined
 are mapped using the partial function, others are discarded.</p><p> <b>Note:</b>
 This combinator is defined only for reactives that contain reference events.
 You cannot call it for reactives whose events are primitive values, such as <code>Int</code>.
 This is because the <code>PartialFunction</code> class is not specialized.
</p></div><dl class="paramcmts block"><dt class="tparam">S</dt><dd class="cmt"><p>the type of the mapped reactive</p></dd><dt class="param">pf</dt><dd class="cmt"><p>partial function used to filter and map events</p></dd><dt class="param">evidence</dt><dd class="cmt"><p>evidence that <code>T</code> is a reference type</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription and a reactive value with the partially mapped events
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd></dl></div>
    </li><li name="scala.reactive.Reactive.ReactiveOps#concat" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="concat[S]()(implicitevidence:&lt;:&lt;[T,scala.reactive.Reactive[S]],implicita:scala.reactive.Arrayable[S],implicitb:scala.reactive.CanBeBuffered):scala.reactive.Reactive[S]withscala.reactive.Reactive.Subscription"></a>
      <a id="concat[S]()(&lt;:&lt;[T,Reactive[S]],Arrayable[S],CanBeBuffered):Reactive[S]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">concat</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="evidence">evidence: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>, <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Reactive.ReactiveOps.concat.S">S</span>]]</span>, <span name="a">a: <a href="package$$Arrayable.html" class="extype" name="scala.reactive.Arrayable">Arrayable</a>[<span class="extype" name="scala.reactive.Reactive.ReactiveOps.concat.S">S</span>]</span>, <span name="b">b: <a href="package$$CanBeBuffered.html" class="extype" name="scala.reactive.CanBeBuffered">CanBeBuffered</a></span>)</span><span class="result">: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Reactive.ReactiveOps.concat.S">S</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Concatenates the events produced by all the reactives emitted by <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Concatenates the events produced by all the reactives emitted by <code>this</code>.</p><p> This operation is only available for reactive values that emit
 other reactives as events.
 Once <code>this</code> and all the reactives unreact, this reactive unreacts.</p><p> <b>Use case:</b></p><pre><span class="kw">def</span> concat[S](): Reactive[S]</pre></div><dl class="paramcmts block"><dt class="tparam">S</dt><dd class="cmt"><p>the type of the events in reactives emitted by <code>this</code></p></dd><dt class="param">evidence</dt><dd class="cmt"><p>evidence that events of type <code>T</code> produced by <code>this</code> are
                   actually reactive values of type <code>S</code></p></dd><dt class="param">a</dt><dd class="cmt"><p>evidence that arrays can be created for type <code>S</code></p></dd><dt class="param">b</dt><dd class="cmt"><p>evidence that buffering events is allowed</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription and the reactive that concatenates all the events
</p></dd></dl><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] performed by method ReactiveOps in <a href="Reactive$.html" class="extype" name="scala.reactive.Reactive">scala.reactive.Reactive</a>.
            
          </dd><dt>Definition Classes</dt><dd><a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a></dd><dt>Note</dt><dd><span class="cmt"><p>This operation potentially buffers events from the nested reactives.
 Unless each reactive emitted by <code>this</code> is known to unreact eventually,
 this operation should not be called.
 To enforce this, clients are required to import the <code>CanBeBuffered</code> evidence
 explicitly into the scope in which they call <code>concat</code>.
</p></span></dd></dl></div>
    </li><li name="scala.reactive.Reactive.ReactiveOps#concat" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="concat(that:scala.reactive.Reactive[T])(implicita:scala.reactive.Arrayable[T],implicitb:scala.reactive.CanBeBuffered):scala.reactive.Reactive[T]withscala.reactive.Reactive.Subscription"></a>
      <a id="concat(Reactive[T])(Arrayable[T],CanBeBuffered):Reactive[T]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">concat</span><span class="params">(<span name="that">that: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="a">a: <a href="package$$Arrayable.html" class="extype" name="scala.reactive.Arrayable">Arrayable</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>, <span name="b">b: <a href="package$$CanBeBuffered.html" class="extype" name="scala.reactive.CanBeBuffered">CanBeBuffered</a></span>)</span><span class="result">: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a concatenation of <code>this</code> and <code>that</code> reactive.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a concatenation of <code>this</code> and <code>that</code> reactive.</p><p> The resulting reactive value produces all the events from <code>this</code> reactive
 until <code>this</code> unreacts, and then outputs all the events from <code>that</code>
 that happened before and after <code>this</code> unreacted.
 To do this, this operation potentially caches all the events from <code>that</code>.
 When <code>that</code> unreacts, the resulting reactive value unreacts.</p><p> <b>Use case:</b></p><pre><span class="kw">def</span> concat(that: Reactive[T]): Reactive[T]</pre></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>another reactive value for the concatenation</p></dd><dt class="param">a</dt><dd class="cmt"><p>evidence that arrays can be created for the type <code>T</code></p></dd><dt class="param">b</dt><dd class="cmt"><p>evidence that the client allows events from <code>that</code> to be buffered</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription and a reactive value that concatenates events from <code>this</code> and <code>that</code>
</p></dd></dl><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] performed by method ReactiveOps in <a href="Reactive$.html" class="extype" name="scala.reactive.Reactive">scala.reactive.Reactive</a>.
            
          </dd><dt>Definition Classes</dt><dd><a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a></dd><dt>Note</dt><dd><span class="cmt"><p>This operation potentially caches events from <code>that</code>.
 Unless certain that <code>this</code> eventually unreacts, <code>concat</code> should not be used.
 To enforce this, clients must import the <code>CanBeBuffered</code> evidence explicitly
 into the scope in which they call <code>concat</code>.
</p></span></dd></dl></div>
    </li><li name="scala.reactive.Signal#diffPast" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="diffPast[S](z:S)(op:(T,T)=&gt;S):scala.reactive.Signal[S]withscala.reactive.Reactive.Subscription"></a>
      <a id="diffPast[S](S)((T,T)⇒S):Signal[S]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">diffPast</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="z">z: <span class="extype" name="scala.reactive.Signal.diffPast.S">S</span></span>)</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>, <span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>) ⇒ <span class="extype" name="scala.reactive.Signal.diffPast.S">S</span></span>)</span><span class="result">: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.diffPast.S">S</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">A signal that produces difference events between the current and previous value of <code>this</code> signal.</p><div class="fullcomment"><div class="comment cmt"><p>A signal that produces difference events between the current and previous value of <code>this</code> signal.</p><pre>time ----------------&gt;
<span class="kw">this</span> --<span class="num">1</span>--<span class="num">3</span>---<span class="num">6</span>---<span class="num">7</span>--&gt;
diff --z--<span class="num">2</span>---<span class="num">3</span>---<span class="num">1</span>--&gt;</pre></div><dl class="paramcmts block"><dt class="tparam">S</dt><dd class="cmt"><p>the type of the difference event</p></dd><dt class="param">z</dt><dd class="cmt"><p>the initial value for the difference</p></dd><dt class="param">op</dt><dd class="cmt"><p>the operator that computes the difference between consecutive events</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription and a signal with the difference value
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a></dd></dl></div>
    </li><li name="scala.Predef.any2Ensuring#ensuring" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ensuring(cond:A=&gt;Boolean,msg:=&gt;Any):A"></a>
      <a id="ensuring((Proxy[T])⇒Boolean,⇒Any):Proxy[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="msg">msg: ⇒ <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <span class="extype" name="scala.Predef.Ensuring">Ensuring</span>[<a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]] performed by method any2Ensuring in scala.Predef.
            
          </dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div>
    </li><li name="scala.Predef.any2Ensuring#ensuring" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ensuring(cond:A=&gt;Boolean):A"></a>
      <a id="ensuring((Proxy[T])⇒Boolean):Proxy[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <span class="extype" name="scala.Predef.Ensuring">Ensuring</span>[<a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]] performed by method any2Ensuring in scala.Predef.
            
          </dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div>
    </li><li name="scala.Predef.any2Ensuring#ensuring" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ensuring(cond:Boolean,msg:=&gt;Any):A"></a>
      <a id="ensuring(Boolean,⇒Any):Proxy[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="msg">msg: ⇒ <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <span class="extype" name="scala.Predef.Ensuring">Ensuring</span>[<a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]] performed by method any2Ensuring in scala.Predef.
            
          </dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div>
    </li><li name="scala.Predef.any2Ensuring#ensuring" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ensuring(cond:Boolean):A"></a>
      <a id="ensuring(Boolean):Proxy[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <span class="extype" name="scala.Predef.Ensuring">Ensuring</span>[<a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]] performed by method any2Ensuring in scala.Predef.
            
          </dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <a href="../package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.reactive.Reactive#filter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="filter(p:T=&gt;Boolean):scala.reactive.Reactive[T]withscala.reactive.Reactive.Subscription"></a>
      <a id="filter((T)⇒Boolean):Reactive[T]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">filter</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Filters events from <code>this</code> reactive value using a specified predicate <code>p</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Filters events from <code>this</code> reactive value using a specified predicate <code>p</code>.</p><p> Only events from <code>this</code> for which <code>p</code> returns <code>true</code> are emitted on the resulting reactive.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>the predicate used to filter events</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription and a reactive with the filtered events
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.reactive.Reactive#foreach" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="foreach(f:T=&gt;Unit):scala.reactive.Reactive[Unit]withscala.reactive.Reactive.Subscription"></a>
      <a id="foreach((T)⇒Unit):Reactive[Unit]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foreach</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.Unit">Unit</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Executes the specified function every time an event arrives.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the specified function every time an event arrives.</p><p> Semantically equivalent to <code>onEvent</code>,
 but supports <code>for</code>-loop syntax with reactive values.</p><pre><span class="kw">for</span> (event <span class="kw">&lt;-</span> r) println(<span class="lit">"Event arrived: "</span> + event)</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the callback invoked when an event arrives</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription that is also a reactive value
                    producing <code>Unit</code> events after each callback invocation
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd></dl></div>
    </li><li name="scala.Predef.any2stringfmt#formatted" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="formatted(fmtstr:String):String"></a>
      <a id="formatted(String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">formatted</span><span class="params">(<span name="fmtstr">fmtstr: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <span class="extype" name="scala.runtime.StringFormat">StringFormat</span> performed by method any2stringfmt in scala.Predef.
            
          </dd><dt>Definition Classes</dt><dd>StringFormat</dd><dt>Annotations</dt><dd>
                <span class="name">@inline</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.reactive.Signal.Proxy#hasSubscriptions" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hasSubscriptions:Boolean"></a>
      <a id="hasSubscriptions:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hasSubscriptions</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Is there any other reactive that depends on the events
 produced by this reactive.</p><div class="fullcomment"><div class="comment cmt"><p>Is there any other reactive that depends on the events
 produced by this reactive.</p><p> Passive reactives, such as <code>Reactive.items</code> will always returns <code>false</code>.
 Other reactives will return <code>true</code> if there are any subscribers attached to them.
 This method is used internally to optimize and recycle some subscriptions away.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a> → <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.reactive.Reactive#isSignal" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isSignal:Boolean"></a>
      <a id="isSignal:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isSignal</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Checks if this reactive value is also a signal.</p><div class="fullcomment"><div class="comment cmt"><p>Checks if this reactive value is also a signal.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p><code>true</code> if the reactive value is a signal, <code>false</code> otherwise
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd></dl></div>
    </li><li name="scala.reactive.Signal#map" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="map[S](f:T=&gt;S):scala.reactive.Signal[S]withscala.reactive.Reactive.Subscription"></a>
      <a id="map[S]((T)⇒S):Signal[S]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>) ⇒ <span class="extype" name="scala.reactive.Signal.map.S">S</span></span>)</span><span class="result">: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.map.S">S</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Maps the signal using the specified mapping function <code>f</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Maps the signal using the specified mapping function <code>f</code>.</p><pre>time ----------------&gt;
<span class="kw">this</span> --<span class="num">1</span>---<span class="num">2</span>----<span class="num">3</span>--<span class="num">4</span>-&gt;
map  --<span class="num">2</span>---<span class="num">4</span>----<span class="num">6</span>--<span class="num">8</span>-&gt;</pre></div><dl class="paramcmts block"><dt class="tparam">S</dt><dd class="cmt"><p>type of the mapped signal</p></dd><dt class="param">f</dt><dd class="cmt"><p>mapping function for the events in <code>this</code> signal</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription and a signal with the mapped events
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a> → <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd></dl></div>
    </li><li name="scala.reactive.Reactive#mutate" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mutate[M&lt;:scala.reactive.ReactMutable](m1:M,m2:M,mr:M*)(mutation:T=&gt;Unit):scala.reactive.Reactive.Subscription"></a>
      <a id="mutate[M&lt;:ReactMutable](M,M,M*)((T)⇒Unit):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mutate</span><span class="tparams">[<span name="M">M &lt;: <a href="ReactMutable.html" class="extype" name="scala.reactive.ReactMutable">ReactMutable</a></span>]</span><span class="params">(<span name="m1">m1: <span class="extype" name="scala.reactive.Reactive.mutate.M">M</span></span>, <span name="m2">m2: <span class="extype" name="scala.reactive.Reactive.mutate.M">M</span></span>, <span name="mr">mr: <span class="extype" name="scala.reactive.Reactive.mutate.M">M</span>*</span>)</span><span class="params">(<span name="mutation">mutation: (<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Mutates multiple reactive mutables <code>m1</code>, <code>m2</code> and <code>mr</code> each time
 <code>this</code> reactive value produces an event.</p><div class="fullcomment"><div class="comment cmt"><p>Mutates multiple reactive mutables <code>m1</code>, <code>m2</code> and <code>mr</code> each time
 <code>this</code> reactive value produces an event.</p><p> This version of the <code>mutate</code> works on multiple reactive values.
</p></div><dl class="paramcmts block"><dt class="tparam">M</dt><dd class="cmt"><p>the type of the reactive mutable value</p></dd><dt class="param">m1</dt><dd class="cmt"><p>the first mutable</p></dd><dt class="param">m2</dt><dd class="cmt"><p>the second mutable</p></dd><dt class="param">mr</dt><dd class="cmt"><p>the rest of the mutables</p></dd><dt class="param">mutation</dt><dd class="cmt"><p>the function that modifies the mutables</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription used to cancel this mutation
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd></dl></div>
    </li><li name="scala.reactive.Reactive#mutate" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mutate[M&lt;:scala.reactive.ReactMutable](mutable:M)(mutation:T=&gt;Unit):scala.reactive.Reactive.Subscription"></a>
      <a id="mutate[M&lt;:ReactMutable](M)((T)⇒Unit):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mutate</span><span class="tparams">[<span name="M">M &lt;: <a href="ReactMutable.html" class="extype" name="scala.reactive.ReactMutable">ReactMutable</a></span>]</span><span class="params">(<span name="mutable">mutable: <span class="extype" name="scala.reactive.Reactive.mutate.M">M</span></span>)</span><span class="params">(<span name="mutation">mutation: (<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Mutates the target reactive mutable called <code>mutable</code> each time <code>this</code> reactive value produces an event.</p><div class="fullcomment"><div class="comment cmt"><p>Mutates the target reactive mutable called <code>mutable</code> each time <code>this</code> reactive value produces an event.</p><p> One type of a reactive mutable is a mutable signal (<code>Signal.Mutable</code>),
 which is a wrapper for regular mutable objects.
 Here is an example, given a reactive of type <code>r</code>:</p><pre><span class="kw">val</span> eventLog = Signal.Mutable(mutable.Buffer[<span class="std">String</span>]())
<span class="kw">val</span> eventLogMutations = r.mutate(eventLog) { event <span class="kw">=&gt;</span>
  eventLog() += <span class="lit">"at "</span> + System.nanoTime + <span class="lit">": "</span> + event
} <span class="cmt">// <-- eventLog event propagated</span></pre><p> Whenever an event arrives on <code>r</code>, an entry is added to the buffer underlying <code>eventLog</code>.
 After the <code>mutation</code> completes, a modification event is produced by the <code>eventLog</code>
 and can be used subsequently:</p><pre><span class="kw">val</span> uiUpdates = eventLog onEvent { b <span class="kw">=&gt;</span>
eventListWidget.add(b.last)
}</pre><p> <b>Use case:</b></p><pre><span class="kw">def</span> mutate(mutable: ReactMutable)(mutation: T <span class="kw">=&gt;</span> <span class="std">Unit</span>): Reactive.Subscription</pre></div><dl class="paramcmts block"><dt class="tparam">M</dt><dd class="cmt"><p>the type of the reactive mutable value</p></dd><dt class="param">mutable</dt><dd class="cmt"><p>the target mutable to be mutated with events from this stream</p></dd><dt class="param">mutation</dt><dd class="cmt"><p>the function that modifies <code>mutable</code> given an event of type <code>T</code></p></dd><dt>returns</dt><dd class="cmt"><p>a subscription used to cancel this mutation
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd><dt>Note</dt><dd><span class="cmt"><p>No two events will ever be concurrently processed by different threads on the same reactive mutable,
 but an event that is propagated from within the <code>mutation</code> can trigger an event on <code>this</code>.
 The result is that <code>mutation</code> is invoked concurrently on the same thread.
 The following code is problematic has a feedback loop in the dataflow graph:</p><pre><span class="kw">val</span> emitter = <span class="kw">new</span> Reactive.Emitter[<span class="std">Int</span>]
<span class="kw">val</span> cell = ReactCell(<span class="num">0</span>) <span class="cmt">// type of ReactMutable</span>
emitter.mutate(cell) { n <span class="kw">=&gt;</span>
  cell := n
  <span class="kw">if</span> (n == <span class="num">0</span>)
    emitter += n + <span class="num">1</span> <span class="cmt">// <-- event propagated</span>
  assert(cell() == n)
}
emitter += <span class="num">0</span></pre><p> The statement <code>emitter += n + 1</code> in the <code>mutate</code> block
 suspends the current mutation, calls the mutation
 recursively and changes the value of <code>cell</code>, and the assertion fails when
 the first mutation resumes.</p><p> Care must be taken to avoid <code>mutation</code> from emitting events that have feedback loops.
</p></span></dd></dl></div>
    </li><li name="scala.reactive.Reactive#mux" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mux[S]()(implicitevidence:&lt;:&lt;[T,scala.reactive.Reactive[S]]):scala.reactive.Reactive[S]"></a>
      <a id="mux[S]()(&lt;:&lt;[T,Reactive[S]]):Reactive[S]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mux</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="evidence">evidence: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>, <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Reactive.mux.S">S</span>]]</span>)</span><span class="result">: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Reactive.mux.S">S</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns events from the last reactive value that <code>this</code> emitted as an event of its own,
 in effect multiplexing the nested reactives.</p><div class="fullcomment"><div class="comment cmt"><p>Returns events from the last reactive value that <code>this</code> emitted as an event of its own,
 in effect multiplexing the nested reactives.</p><p> The resulting reactive only emits events from the reactive value last emitted by <code>this</code>,
 the preceding reactive values are ignored.</p><p> This combinator is only available if this reactive value emits events
 that are themselves reactive values.</p><p> Example:</p><pre><span class="kw">val</span> currentReactive = <span class="kw">new</span> Reactive.Emitter[Reactive[<span class="std">Int</span>]]
<span class="kw">val</span> e1 = <span class="kw">new</span> Reactive.Emitter[<span class="std">Int</span>]
<span class="kw">val</span> e2 = <span class="kw">new</span> Reactive.Emitter[<span class="std">Int</span>]
<span class="kw">val</span> currentEvent = currentReactive.mux()
<span class="kw">val</span> prints = currentEvent.onEvent(println)

currentReactive += e1
e2 += <span class="num">1</span> <span class="cmt">// nothing is printed</span>
e1 += <span class="num">2</span> <span class="cmt">// 2 is printed</span>
currentReactive += e2
e2 += <span class="num">6</span> <span class="cmt">// 6 is printed</span>
e1 += <span class="num">7</span> <span class="cmt">// nothing is printed</span></pre><p> Shown on the diagram:</p><pre>time            -------------------&gt;
currentReactive --e1------e2-------&gt;
e1              --------<span class="num">2</span>----<span class="num">6</span>-----&gt;
e2              -----<span class="num">1</span>----------<span class="num">7</span>--&gt;
currentEvent    --------<span class="num">2</span>----<span class="num">6</span>-----&gt;</pre><p> <b>Use case:</b></p><pre><span class="kw">def</span> mux[S](): Reactive[S]</pre></div><dl class="paramcmts block"><dt class="tparam">S</dt><dd class="cmt"><p>the type of the events in the nested reactive</p></dd><dt class="param">evidence</dt><dd class="cmt"><p>an implicit evidence that <code>this</code> reactive is nested --
                    it emits events of type <code>T</code> that is actually a <code>Reactive[S]</code></p></dd><dt>returns</dt><dd class="cmt"><p>a reactive of events from the reactive last emitted by <code>this</code>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd></dl></div>
    </li><li name="scala.reactive.Signal#muxSignal" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="muxSignal[S]()(implicitevidence:&lt;:&lt;[T,scala.reactive.Signal[S]]):scala.reactive.Signal[S]withscala.reactive.Reactive.Subscription"></a>
      <a id="muxSignal[S]()(&lt;:&lt;[T,Signal[S]]):Signal[S]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">muxSignal</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="evidence">evidence: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>, <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.muxSignal.S">S</span>]]</span>)</span><span class="result">: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.muxSignal.S">S</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a signal that uses the current signal nested in <code>this</code> signal to compute the resulting value,
 in effect multiplexing the nested signals.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a signal that uses the current signal nested in <code>this</code> signal to compute the resulting value,
 in effect multiplexing the nested signals.</p><p> Whenever the nested signal changes, or the value of the nested signal changes,
 an event with the current nested signal value is emitted
 and stored as the value of the resulting signal.</p><p> Unreacts when both <code>this</code> and the last nested signal unreact.</p><pre>time      --------------------------------&gt;
<span class="kw">this</span>      <span class="num">1</span>--<span class="num">2</span>--<span class="num">3</span>----<span class="num">4</span>--<span class="num">5</span>--<span class="num">6</span>--------------&gt;
                   <span class="num">0</span>--<span class="num">0</span>--<span class="num">0</span>-----<span class="num">0</span>---<span class="num">0</span>--<span class="num">0</span>---&gt;
                             <span class="num">1</span>--<span class="num">2</span>---<span class="num">4</span>--<span class="num">8</span>--&gt;
muxSignal <span class="num">1</span>--<span class="num">2</span>--<span class="num">3</span>--<span class="num">0</span>--<span class="num">0</span>--<span class="num">0</span>---<span class="num">1</span>--<span class="num">2</span>---<span class="num">4</span>--<span class="num">8</span>--&gt;</pre><p> This is similar to <code>mux</code>, but emits the initial value of the signal as an event too --
 this is because <code>mux</code> does not require the nested reactive to be a signal.</p><p> <b>Use case:</b></p><pre><span class="kw">def</span> muxSignal[S](): Signal[S]</pre></div><dl class="paramcmts block"><dt class="tparam">S</dt><dd class="cmt"><p>type of the nested signal</p></dd><dt class="param">evidence</dt><dd class="cmt"><p>evidence that the type of <code>this</code> signal <code>T</code> is a signal of type <code>S</code></p></dd><dt>returns</dt><dd class="cmt"><p>a subscription and a signal with the multiplexed values.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <a href="../package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.reactive.Reactive#on" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="on(reactor:=&gt;Unit):scala.reactive.Reactive.Subscription"></a>
      <a id="on(⇒Unit):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">on</span><span class="params">(<span name="reactor">reactor: ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">A shorthand for <code>onReaction</code> -- called whenever an event occurs.</p><div class="fullcomment"><div class="comment cmt"><p>A shorthand for <code>onReaction</code> -- called whenever an event occurs.</p><p> This method is handy when the precise event is not important,
 or the type of the event is <code>Unit</code>.
</p></div><dl class="paramcmts block"><dt class="param">reactor</dt><dd class="cmt"><p>the callback invoked when an event arrives</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription for unsubscribing from reactions
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd></dl></div>
    </li><li name="scala.reactive.Reactive#onCase" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onCase(reactor:PartialFunction[T,Unit])(implicitsub:&lt;:&lt;[T,AnyRef]):scala.reactive.Reactive.Subscription"></a>
      <a id="onCase(PartialFunction[T,Unit])(&lt;:&lt;[T,AnyRef]):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onCase</span><span class="params">(<span name="reactor">reactor: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>, <span class="extype" name="scala.Unit">Unit</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="sub">sub: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>, <a href="../package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a>]</span>)</span><span class="result">: <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">A shorthand for <code>onReaction</code> -- the specified partial function is applied to only those events
 for which is defined.</p><div class="fullcomment"><div class="comment cmt"><p>A shorthand for <code>onReaction</code> -- the specified partial function is applied to only those events
 for which is defined.</p><p> This method only works for <code>AnyRef</code> values.</p><p> Example:</p><pre>r onCase {
<span class="kw">case</span> s: <span class="std">String</span> <span class="kw">=&gt;</span> println(s)
<span class="kw">case</span> n: <span class="std">Int</span>    <span class="kw">=&gt;</span> println(<span class="lit">"number "</span> + s)
}</pre><p> <b>Use case</b>:</p><pre><span class="kw">def</span> onCase(reactor: PartialFunction[T, <span class="std">Unit</span>]): Reactive.Subscription</pre></div><dl class="paramcmts block"><dt class="param">reactor</dt><dd class="cmt"><p>the callback for those events for which it is defined</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription for unsubscribing from reactions
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd></dl></div>
    </li><li name="scala.reactive.Reactive#onEvent" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onEvent(reactor:T=&gt;Unit):scala.reactive.Reactive.Subscription"></a>
      <a id="onEvent((T)⇒Unit):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onEvent</span><span class="params">(<span name="reactor">reactor: (<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">A shorthand for <code>onReaction</code> -- the specified function is invoked whenever there is an event.</p><div class="fullcomment"><div class="comment cmt"><p>A shorthand for <code>onReaction</code> -- the specified function is invoked whenever there is an event.
</p></div><dl class="paramcmts block"><dt class="param">reactor</dt><dd class="cmt"><p>the callback for events</p></dd><dt>returns</dt><dd class="cmt"><p>a subcriptions for unsubscribing from reactions
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd></dl></div>
    </li><li name="scala.reactive.Signal.Proxy#onReaction" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onReaction(r:scala.reactive.Reactor[T]):scala.reactive.Reactive.Subscription"></a>
      <a id="onReaction(Reactor[T]):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onReaction</span><span class="params">(<span name="r">r: <a href="Reactor.html" class="extype" name="scala.reactive.Reactor">Reactor</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>)</span><span class="result">: <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Attaches a new <code>reactor</code> to this reactive
 that is called multiple times when an event is produced
 and once when the reactive is terminated.</p><div class="fullcomment"><div class="comment cmt"><p>Attaches a new <code>reactor</code> to this reactive
 that is called multiple times when an event is produced
 and once when the reactive is terminated.</p><p> Reactives can create events specifically for this reactor,
 in which case they are called <i>passive</i>.
 A passive reactive can create events both synchronously and asynchronously,
 but it will only do so on its own isolate.</p><p> An <i>active</i> reactive value will produce events irregardless of the reactors subscribed to it.
 Subscribing to an active reactive value only forwards those events that have
 been produced after the subscription started.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a subscription for unsubscribing from reactions
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a> → <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd></dl></div>
    </li><li name="scala.reactive.Reactive#onUnreact" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onUnreact(reactor:=&gt;Unit):scala.reactive.Reactive.Subscription"></a>
      <a id="onUnreact(⇒Unit):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onUnreact</span><span class="params">(<span name="reactor">reactor: ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Executes the specified block when <code>this</code> reactive unreacts.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the specified block when <code>this</code> reactive unreacts.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a subscription for the unreaction notification
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd></dl></div>
    </li><li name="scala.reactive.Signal#renewed" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="renewed:scala.reactive.Signal[T]withscala.reactive.Reactive.Subscription"></a>
      <a id="renewed:Signal[T]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">renewed</span><span class="result">: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">A renewed instance of this signal emitting the same events,
 but having a different set of subscribers.</p><div class="fullcomment"><div class="comment cmt"><p>A renewed instance of this signal emitting the same events,
 but having a different set of subscribers.</p><pre>time    -------------&gt;
<span class="kw">this</span>    --<span class="num">1</span>----<span class="num">2</span>--<span class="num">3</span>--&gt;
renewed --<span class="num">1</span>----<span class="num">2</span>--<span class="num">3</span>--&gt;</pre></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a subscription and a new instance of <code>this</code> signal
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a></dd></dl></div>
    </li><li name="scala.reactive.Reactive#scanPast" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scanPast[S](z:S)(op:(S,T)=&gt;S):scala.reactive.Signal[S]withscala.reactive.Reactive.Subscription"></a>
      <a id="scanPast[S](S)((S,T)⇒S):Signal[S]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanPast</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="z">z: <span class="extype" name="scala.reactive.Reactive.scanPast.S">S</span></span>)</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.reactive.Reactive.scanPast.S">S</span>, <span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>) ⇒ <span class="extype" name="scala.reactive.Reactive.scanPast.S">S</span></span>)</span><span class="result">: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Reactive.scanPast.S">S</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a new reactive <code>s</code> that produces events by consecutively
 applying the specified operator <code>op</code> to the previous event that <code>s</code>
 produced and the current event that this reactive value produced.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new reactive <code>s</code> that produces events by consecutively
 applying the specified operator <code>op</code> to the previous event that <code>s</code>
 produced and the current event that this reactive value produced.</p><p> The <code>scanPast</code> operation allows the current event from this reactive to be mapped into a different
 event by looking &quot;into the past&quot;, i.e. at the event previously emitted by the resulting reactive.</p><p> Example -- assume that a reactive value <code>r</code> produces events <code>1</code>, <code>2</code> and <code>3</code>.
 The following <code>s</code>:</p><pre><span class="kw">val</span> s = r.scanPast(<span class="num">0</span>)((sum, n) <span class="kw">=&gt;</span> sum + n)</pre><p> will produce events <code>1</code>, <code>3</code> (<code>1 + 2</code>) and <code>6</code> (<code>3 + 3</code>).
 <b>Note:</b> the initial value <code>0</code> is <b>not emitted</b>.</p><p> The <code>scanPast</code> can also be used to produce a reactive value of a different type:
 The following produces a complete history of all the events seen so far:</p><pre><span class="kw">val</span> s2 = r.scanPast(<span class="std">List</span>[<span class="std">Int</span>]()) {
(history, n) <span class="kw">=&gt;</span> n :: history
}</pre><p> The <code>s2</code> will produce events <code>1 :: Nil</code>, <code>2 :: 1 :: Nil</code> and <code>3 :: 2 :: 1 :: Nil</code>.
 <b>Note:</b> the initial value <code>Nil</code> is <b>not emitted</b>.</p><p> The resulting reactive value is not only a reactive value, but also a <code>Signal</code>,
 so the value of the previous event can be obtained by calling <code>apply</code> at any time.</p><p> This operation is closely related to a <code>scanLeft</code> on a collection --
 if a reactive value were a sequence of elements, then <code>scanLeft</code> would produce
 a new sequence whose elements correspond to the events of the resulting reactive.
</p></div><dl class="paramcmts block"><dt class="tparam">S</dt><dd class="cmt"><p>the type of the events in the resulting reactive value</p></dd><dt class="param">z</dt><dd class="cmt"><p>the initial value of the scan past</p></dd><dt class="param">op</dt><dd class="cmt"><p>the operator the combines the last produced and the current event into a new one</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription that is also a reactive value that scans events from <code>this</code> reactive value
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd></dl></div>
    </li><li name="scala.reactive.Reactive.ReactiveOps#signal" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="signal(init:T):scala.reactive.Signal[T]withscala.reactive.Reactive.Subscription"></a>
      <a id="signal(T):Signal[T]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">signal</span><span class="params">(<span name="init">init: <span class="extype" name="scala.reactive.Signal.Proxy.T">T</span></span>)</span><span class="result">: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Given an initial event <code>init</code>, converts this reactive into a <code>Signal</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Given an initial event <code>init</code>, converts this reactive into a <code>Signal</code>.</p><p> The resulting signal initially contains the event <code>init</code>,
 and subsequently any event that the <code>this</code> reactive produces.
</p></div><dl class="paramcmts block"><dt class="param">init</dt><dd class="cmt"><p>an initial value for the signal</p></dd><dt>returns</dt><dd class="cmt"><p>the signal version of the current reactive
</p></dd></dl><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] performed by method ReactiveOps in <a href="Reactive$.html" class="extype" name="scala.reactive.Reactive">scala.reactive.Reactive</a>.
            
          </dd><dt>Definition Classes</dt><dd><a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a></dd></dl></div>
    </li><li name="scala.reactive.Reactive.ReactiveOps#sync" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sync[S,R](that:scala.reactive.Reactive[S])(f:(T,S)=&gt;R)(implicitat:scala.reactive.Arrayable[T],implicitas:scala.reactive.Arrayable[S],implicitb:scala.reactive.CanBeBuffered):scala.reactive.Reactive[R]withscala.reactive.Reactive.Subscription"></a>
      <a id="sync[S,R](Reactive[S])((T,S)⇒R)(Arrayable[T],Arrayable[S],CanBeBuffered):Reactive[R]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">sync</span><span class="tparams">[<span name="S">S</span>, <span name="R">R</span>]</span><span class="params">(<span name="that">that: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Reactive.ReactiveOps.sync.S">S</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>, <span class="extype" name="scala.reactive.Reactive.ReactiveOps.sync.S">S</span>) ⇒ <span class="extype" name="scala.reactive.Reactive.ReactiveOps.sync.R">R</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="at">at: <a href="package$$Arrayable.html" class="extype" name="scala.reactive.Arrayable">Arrayable</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>, <span name="as">as: <a href="package$$Arrayable.html" class="extype" name="scala.reactive.Arrayable">Arrayable</a>[<span class="extype" name="scala.reactive.Reactive.ReactiveOps.sync.S">S</span>]</span>, <span name="b">b: <a href="package$$CanBeBuffered.html" class="extype" name="scala.reactive.CanBeBuffered">CanBeBuffered</a></span>)</span><span class="result">: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Reactive.ReactiveOps.sync.R">R</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Syncs the arrival of events from <code>this</code> and <code>that</code> reactive value.</p><div class="fullcomment"><div class="comment cmt"><p>Syncs the arrival of events from <code>this</code> and <code>that</code> reactive value.</p><p> Ensures that pairs of events from this reactive value and that reactive value
 are emitted together.
 If the events produced in time by <code>this</code> and <code>that</code>, the sync will be as follows:</p><pre>time   ---------------------------&gt;
<span class="kw">this</span>   ----<span class="num">1</span>---------<span class="num">2</span>-------<span class="num">4</span>----&gt;
that   --<span class="num">1</span>-----<span class="num">2</span>--<span class="num">3</span>---------------&gt;
sync   ----<span class="num">1</span>,<span class="num">1</span>-------<span class="num">2</span>,<span class="num">2</span>-----<span class="num">4</span>,<span class="num">3</span>--&gt;</pre><p> Pairs of events produced from <code>this</code> and <code>that</code> are then transformed using
 specified function <code>f</code>.
 For example, clients that want to output tuples do:</p><pre><span class="kw">val</span> synced = (a sync b) { (a, b) <span class="kw">=&gt;</span> (a, b) }</pre><p> Clients that, for example, want to create differences in pairs of events do:</p><pre><span class="kw">val</span> diffs = (a sync b)(_ - _)</pre><p> The resulting reactive unreacts either when
 <code>this</code> unreacts and there are no more buffered events from this,
 or when <code>that</code> unreacts and there are no more buffered events from <code>that</code>.</p><p> <b>Use case:</b></p><pre><span class="kw">def</span> sync[S, R](that: Reactive[S])(f: (T, S) <span class="kw">=&gt;</span> R): Reactive[R]</pre></div><dl class="paramcmts block"><dt class="tparam">S</dt><dd class="cmt"><p>the type of the events in <code>that</code> reactive</p></dd><dt class="tparam">R</dt><dd class="cmt"><p>the type of the events in the resulting reactive</p></dd><dt class="param">that</dt><dd class="cmt"><p>the reactive to sync with</p></dd><dt class="param">f</dt><dd class="cmt"><p>the mapping function for the pair of events</p></dd><dt class="param">at</dt><dd class="cmt"><p>evidence that arrays can be created for the type <code>T</code></p></dd><dt class="param">as</dt><dd class="cmt"><p>evidence that arrays can be created for the type <code>S</code></p></dd><dt class="param">b</dt><dd class="cmt"><p>evidence that the client allows events to be buffered</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription and the reactive with the resulting events
</p></dd></dl><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] performed by method ReactiveOps in <a href="Reactive$.html" class="extype" name="scala.reactive.Reactive">scala.reactive.Reactive</a>.
            
          </dd><dt>Definition Classes</dt><dd><a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a></dd><dt>Note</dt><dd><span class="cmt"><p>This operation potentially caches events from <code>this</code> and <code>that</code>.
 Unless certain that both <code>this</code> produces a bounded number of events
 before the <code>that</code> produces an event, and vice versa, this operation should not be called.
 To enforce this, clients must import the <code>CanBeBuffered</code> evidence explicitly
 into the scope in which they call <code>sync</code>.
</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.reactive.Reactive.ReactiveOps#union" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="union[S]()(implicitevidence:&lt;:&lt;[T,scala.reactive.Reactive[S]]):scala.reactive.Reactive[S]withscala.reactive.Reactive.Subscription"></a>
      <a id="union[S]()(&lt;:&lt;[T,Reactive[S]]):Reactive[S]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">union</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="evidence">evidence: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>, <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Reactive.ReactiveOps.union.S">S</span>]]</span>)</span><span class="result">: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Reactive.ReactiveOps.union.S">S</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Unifies the events produced by all the reactives emitted by <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Unifies the events produced by all the reactives emitted by <code>this</code>.</p><p> This operation is only available for reactive values that emit
 other reactives as events.
 The resulting reactive unifies events of all the reactives emitted by <code>this</code>.
 Once <code>this</code> and all the reactives emitted by <code>this</code> unreact, the resulting reactive terminates.</p><p> Example:</p><pre>time  --------------------------&gt;
<span class="kw">this</span>     --<span class="num">1</span>----<span class="num">2</span>--------<span class="num">3</span>------&gt;
             ---------<span class="num">5</span>----<span class="num">6</span>----&gt;
               ---<span class="num">4</span>----------<span class="num">7</span>--&gt;
union -----<span class="num">1</span>----<span class="num">2</span>-<span class="num">4</span>---<span class="num">5</span>--<span class="num">3</span>-<span class="num">6</span>-<span class="num">7</span>--&gt;</pre><p> <b>Use case:</b></p><pre><span class="kw">def</span> union[S](): Reactive[S]</pre></div><dl class="paramcmts block"><dt class="tparam">S</dt><dd class="cmt"><p>the type of the events in reactives emitted by <code>this</code></p></dd><dt class="param">evidence</dt><dd class="cmt"><p>evidence that events of type <code>T</code> produced by <code>this</code> are
                   actually reactive values of type <code>S</code></p></dd><dt>returns</dt><dd class="cmt"><p>a subscription and the reactive with the union of all the events</p></dd></dl><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] performed by method ReactiveOps in <a href="Reactive$.html" class="extype" name="scala.reactive.Reactive">scala.reactive.Reactive</a>.
            
          </dd><dt>Definition Classes</dt><dd><a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a></dd></dl></div>
    </li><li name="scala.reactive.Reactive.ReactiveOps#union" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="union(that:scala.reactive.Reactive[T]):scala.reactive.Reactive[T]withscala.reactive.Reactive.Subscription"></a>
      <a id="union(Reactive[T]):Reactive[T]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit">union</span><span class="params">(<span name="that">that: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>)</span><span class="result">: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a union of <code>this</code> and <code>that</code> reactive.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a union of <code>this</code> and <code>that</code> reactive.</p><p> The resulting reactive value emits events from both <code>this</code> and <code>that</code> reactive.
 It unreacts when both <code>this</code> and <code>that</code> reactive unreact.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>another reactive value for the union</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription and the reactive value with unified events from <code>this</code> and <code>that</code>
</p></dd></dl><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] performed by method ReactiveOps in <a href="Reactive$.html" class="extype" name="scala.reactive.Reactive">scala.reactive.Reactive</a>.
            
          </dd><dt>Definition Classes</dt><dd><a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a></dd></dl></div>
    </li><li name="scala.reactive.Reactive#until" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="until[S](that:scala.reactive.Reactive[S]):scala.reactive.Reactive[T]withscala.reactive.Reactive.Subscription"></a>
      <a id="until[S](Reactive[S]):Reactive[T]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">until</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="that">that: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Reactive.until.S">S</span>]</span>)</span><span class="result">: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a new reactive value that produces events from <code>this</code> reactive value
 until <code>that</code> produces an event.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new reactive value that produces events from <code>this</code> reactive value
 until <code>that</code> produces an event.</p><p> If <code>this</code> unreacts before <code>that</code> produces a value, the resulting reactive unreacts.
 Otherwise, the resulting reactive unreacts whenever <code>that</code> produces a value.
</p></div><dl class="paramcmts block"><dt class="tparam">S</dt><dd class="cmt"><p>the type of <code>that</code> reactive</p></dd><dt class="param">that</dt><dd class="cmt"><p>the reactive until whose first event the result propagates events</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription and the resulting reactive that emits only until <code>that</code> emits
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a></dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.reactive.Signal#zip" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zip[S,R](that:scala.reactive.Signal[S])(f:(T,S)=&gt;R):scala.reactive.Signal[R]withscala.reactive.Reactive.Subscription"></a>
      <a id="zip[S,R](Signal[S])((T,S)⇒R):Signal[R]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zip</span><span class="tparams">[<span name="S">S</span>, <span name="R">R</span>]</span><span class="params">(<span name="that">that: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.zip.S">S</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>, <span class="extype" name="scala.reactive.Signal.zip.S">S</span>) ⇒ <span class="extype" name="scala.reactive.Signal.zip.R">R</span></span>)</span><span class="result">: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.zip.R">R</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Zips values of <code>this</code> and <code>that</code> signal using the specified function <code>f</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Zips values of <code>this</code> and <code>that</code> signal using the specified function <code>f</code>.</p><p> Whenever either of the two signals change the resulting signal also changes.
 When <code>this</code> emits an event, the current value of <code>that</code> is used to produce a signal on <code>that</code>,
 and vice versa.</p><pre>time ---------------------------------&gt;
<span class="kw">this</span> --<span class="num">1</span>----<span class="num">2</span>-----<span class="num">4</span>----------<span class="num">8</span>--------&gt;
that --a----------------b---------c---&gt;
zip  --<span class="num">1</span>,a--<span class="num">2</span>,a---<span class="num">4</span>,a---<span class="num">4</span>,b--<span class="num">8</span>,b--<span class="num">8</span>,c-&gt;</pre><p> The resulting tuple of events from <code>this</code> and <code>that</code> is mapped using the
 user-specified mapping function <code>f</code>.
 For example, to produce tuples:</p><pre><span class="kw">val</span> tuples = (a zip b) { (a, b) <span class="kw">=&gt;</span> (a, b) }</pre><p> To produce the difference between two integer signals:</p><pre><span class="kw">val</span> differences = (a zip b)(_ - _)</pre><p> <b>Note:</b>: clients looking into pairing incoming events from two signals
 you should use the <code>sync</code> method inherited from <code>Reactive</code>.
</p></div><dl class="paramcmts block"><dt class="tparam">S</dt><dd class="cmt"><p>the type of <code>that</code> signal</p></dd><dt class="tparam">R</dt><dd class="cmt"><p>the type of the resulting signal</p></dd><dt class="param">that</dt><dd class="cmt"><p>the signal to zip <code>this</code> with</p></dd><dt class="param">f</dt><dd class="cmt"><p>the function that maps a tuple of values into an outgoing event</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription and the reactive that emits zipped events
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a></dd></dl></div>
    </li><li name="scala.Predef.any2ArrowAssoc#→" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="→[B](y:B):(A,B)"></a>
      <a id="→[B](B):(Proxy[T],B)"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $u2192" class="implicit">→</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span class="extype" name="scala.Predef.ArrowAssoc.→.B">B</span></span>)</span><span class="result">: (<a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>], <span class="extype" name="scala.Predef.ArrowAssoc.→.B">B</span>)</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <span class="extype" name="scala.Predef.ArrowAssoc">ArrowAssoc</span>[<a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]] performed by method any2ArrowAssoc in scala.Predef.
            
          </dd><dt>Definition Classes</dt><dd>ArrowAssoc</dd></dl></div>
    </li></ol>
            </div>

        <div id="values" class="values members">
              <h3>Shadowed Implicit Value Members</h3>
              <ol><li name="scala.reactive.Signal.SignalOps#past2" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="past2(init:T):scala.reactive.Signal[(T,T)]withscala.reactive.Reactive.Subscription"></a>
      <a id="past2(T):Signal[(T,T)]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit shadowed">past2</span><span class="params">(<span name="init">init: <span class="extype" name="scala.reactive.Signal.Proxy.T">T</span></span>)</span><span class="result">: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[(<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>, <span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>)] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a new signal that emits tuples of the current
 and the last event emitted by <code>this</code> signal.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new signal that emits tuples of the current
 and the last event emitted by <code>this</code> signal.</p><pre>time  ----------------------&gt;
<span class="kw">this</span>  <span class="num">1</span>----<span class="num">2</span>------<span class="num">3</span>----<span class="num">4</span>----&gt;
past2 i,<span class="num">1</span>--<span class="num">1</span>,<span class="num">2</span>----<span class="num">2</span>,<span class="num">3</span>--<span class="num">3</span>,<span class="num">4</span>--&gt;</pre></div><dl class="paramcmts block"><dt class="param">init</dt><dd class="cmt"><p>the initial previous value, <code>i</code> in the diagram above</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription and a signal of tuples of the current and last event
</p></dd></dl><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <a href="Signal$$SignalOps.html" class="extype" name="scala.reactive.Signal.SignalOps">SignalOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] performed by method SignalOps in <a href="Signal$.html" class="extype" name="scala.reactive.Signal">scala.reactive.Signal</a>.
            
          </dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br />To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br /><div class="cmt"><pre>(proxy: SignalOps[T]).past2(init)</pre></div></dd><dt>Definition Classes</dt><dd><a href="Signal$$SignalOps.html" class="extype" name="scala.reactive.Signal.SignalOps">SignalOps</a></dd></dl></div>
    </li><li name="scala.reactive.Signal.SignalOps#past2" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="past2(init:T):scala.reactive.Signal[(T,T)]withscala.reactive.Reactive.Subscription"></a>
      <a id="past2(T):Signal[(T,T)]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit shadowed">past2</span><span class="params">(<span name="init">init: <span class="extype" name="scala.reactive.Signal.Proxy.T">T</span></span>)</span><span class="result">: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[(<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>, <span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>)] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a new signal that emits tuples of the current
 and the last event emitted by <code>this</code> signal.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new signal that emits tuples of the current
 and the last event emitted by <code>this</code> signal.</p><pre>time  ----------------------&gt;
<span class="kw">this</span>  <span class="num">1</span>----<span class="num">2</span>------<span class="num">3</span>----<span class="num">4</span>----&gt;
past2 i,<span class="num">1</span>--<span class="num">1</span>,<span class="num">2</span>----<span class="num">2</span>,<span class="num">3</span>--<span class="num">3</span>,<span class="num">4</span>--&gt;</pre></div><dl class="paramcmts block"><dt class="param">init</dt><dd class="cmt"><p>the initial previous value, <code>i</code> in the diagram above</p></dd><dt>returns</dt><dd class="cmt"><p>a subscription and a signal of tuples of the current and last event
</p></dd></dl><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <a href="Signal$$SignalOps.html" class="extype" name="scala.reactive.Signal.SignalOps">SignalOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] performed by method SignalOps in <a href="Signal$.html" class="extype" name="scala.reactive.Signal">scala.reactive.Signal</a>.
            
          </dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br />To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br /><div class="cmt"><pre>(proxy: SignalOps[T]).past2(init)</pre></div></dd><dt>Definition Classes</dt><dd><a href="Signal$$SignalOps.html" class="extype" name="scala.reactive.Signal.SignalOps">SignalOps</a></dd></dl></div>
    </li><li name="scala.reactive.Signal.SignalOps#scanPastNow" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scanPastNow(op:(T,T)=&gt;T):scala.reactive.Signal[T]withscala.reactive.Reactive.Subscription"></a>
      <a id="scanPastNow((T,T)⇒T):Signal[T]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit shadowed">scanPastNow</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>, <span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>) ⇒ <span class="extype" name="scala.reactive.Signal.Proxy.T">T</span></span>)</span><span class="result">: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Scans the events in the past of <code>this</code> signal starting from the
 current value of <code>this</code> signal.</p><div class="fullcomment"><div class="comment cmt"><p>Scans the events in the past of <code>this</code> signal starting from the
 current value of <code>this</code> signal.</p><pre>time        --------------------&gt;
<span class="kw">this</span>        <span class="num">1</span>--<span class="num">2</span>----<span class="num">4</span>-----<span class="num">8</span>-----&gt;
scanPastNow <span class="num">1</span>--<span class="num">3</span>----<span class="num">7</span>-----<span class="num">15</span>----&gt;</pre></div><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <a href="Signal$$SignalOps.html" class="extype" name="scala.reactive.Signal.SignalOps">SignalOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] performed by method SignalOps in <a href="Signal$.html" class="extype" name="scala.reactive.Signal">scala.reactive.Signal</a>.
            
          </dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br />To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br /><div class="cmt"><pre>(proxy: SignalOps[T]).scanPastNow(op)</pre></div></dd><dt>Definition Classes</dt><dd><a href="Signal$$SignalOps.html" class="extype" name="scala.reactive.Signal.SignalOps">SignalOps</a></dd></dl></div>
    </li><li name="scala.reactive.Signal.SignalOps#scanPastNow" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scanPastNow(op:(T,T)=&gt;T):scala.reactive.Signal[T]withscala.reactive.Reactive.Subscription"></a>
      <a id="scanPastNow((T,T)⇒T):Signal[T]withSubscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit shadowed">scanPastNow</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>, <span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>) ⇒ <span class="extype" name="scala.reactive.Signal.Proxy.T">T</span></span>)</span><span class="result">: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] with <a href="Reactive$$Subscription.html" class="extype" name="scala.reactive.Reactive.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Scans the events in the past of <code>this</code> signal starting from the
 current value of <code>this</code> signal.</p><div class="fullcomment"><div class="comment cmt"><p>Scans the events in the past of <code>this</code> signal starting from the
 current value of <code>this</code> signal.</p><pre>time        --------------------&gt;
<span class="kw">this</span>        <span class="num">1</span>--<span class="num">2</span>----<span class="num">4</span>-----<span class="num">8</span>-----&gt;
scanPastNow <span class="num">1</span>--<span class="num">3</span>----<span class="num">7</span>-----<span class="num">15</span>----&gt;</pre></div><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <a href="Signal$$SignalOps.html" class="extype" name="scala.reactive.Signal.SignalOps">SignalOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] performed by method SignalOps in <a href="Signal$.html" class="extype" name="scala.reactive.Signal">scala.reactive.Signal</a>.
            
          </dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br />To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br /><div class="cmt"><pre>(proxy: SignalOps[T]).scanPastNow(op)</pre></div></dd><dt>Definition Classes</dt><dd><a href="Signal$$SignalOps.html" class="extype" name="scala.reactive.Signal.SignalOps">SignalOps</a></dd></dl></div>
    </li><li name="scala.reactive.Reactive.ReactiveOps#self" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="self:scala.reactive.Reactive[T]"></a>
      <a id="self:Reactive[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="implicit shadowed">self</span><span class="result">: <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] performed by method ReactiveOps in <a href="Reactive$.html" class="extype" name="scala.reactive.Reactive">scala.reactive.Reactive</a>.
            
          </dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br />To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br /><div class="cmt"><pre>(proxy: ReactiveOps[T]).self</pre></div></dd><dt>Definition Classes</dt><dd><a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a></dd></dl></div>
    </li><li name="scala.reactive.Signal.SignalOps#self" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="self:scala.reactive.Signal[T]"></a>
      <a id="self:Signal[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="implicit shadowed">self</span><span class="result">: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <a href="Signal$$SignalOps.html" class="extype" name="scala.reactive.Signal.SignalOps">SignalOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] performed by method SignalOps in <a href="Signal$.html" class="extype" name="scala.reactive.Signal">scala.reactive.Signal</a>.
            
          </dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br />To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br /><div class="cmt"><pre>(proxy: SignalOps[T]).self</pre></div></dd><dt>Definition Classes</dt><dd><a href="Signal$$SignalOps.html" class="extype" name="scala.reactive.Signal.SignalOps">SignalOps</a></dd></dl></div>
    </li><li name="scala.reactive.Signal.SignalOps#self" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="self:scala.reactive.Signal[T]"></a>
      <a id="self:Signal[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="implicit shadowed">self</span><span class="result">: <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <a href="Signal$$SignalOps.html" class="extype" name="scala.reactive.Signal.SignalOps">SignalOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] performed by method SignalOps in <a href="Signal$.html" class="extype" name="scala.reactive.Signal">scala.reactive.Signal</a>.
            
          </dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br />To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br /><div class="cmt"><pre>(proxy: SignalOps[T]).self</pre></div></dd><dt>Definition Classes</dt><dd><a href="Signal$$SignalOps.html" class="extype" name="scala.reactive.Signal.SignalOps">SignalOps</a></dd></dl></div>
    </li><li name="scala.Predef.any2stringadd#self" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="self:Any"></a>
      <a id="self:Any"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="implicit shadowed">self</span><span class="result">: <span class="extype" name="scala.Any">Any</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <span class="extype" name="scala.runtime.StringAdd">StringAdd</span> performed by method any2stringadd in scala.Predef.
            
          </dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br />To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br /><div class="cmt"><pre>(proxy: StringAdd).self</pre></div></dd><dt>Definition Classes</dt><dd>StringAdd</dd></dl></div>
    </li><li name="scala.Predef.any2stringfmt#self" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="self:Any"></a>
      <a id="self:Any"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="implicit shadowed">self</span><span class="result">: <span class="extype" name="scala.Any">Any</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <span class="extype" name="scala.runtime.StringFormat">StringFormat</span> performed by method any2stringfmt in scala.Predef.
            
          </dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br />To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br /><div class="cmt"><pre>(proxy: StringFormat).self</pre></div></dd><dt>Definition Classes</dt><dd>StringFormat</dd></dl></div>
    </li></ol>
            </div>

        <div id="values" class="values members">
              <h3>Deprecated Value Members</h3>
              <ol><li name="scala.Predef.any2ArrowAssoc#x" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="x:A"></a>
      <a id="x:Proxy[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit shadowed deprecated" title="Deprecated: (Since version 2.10.0) Use leftOfArrow instead">x</span><span class="result">: <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <span class="extype" name="scala.Predef.ArrowAssoc">ArrowAssoc</span>[<a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]] performed by method any2ArrowAssoc in scala.Predef.
            
          </dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br />To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br /><div class="cmt"><pre>(proxy: ArrowAssoc[Proxy[T]]).x</pre></div></dd><dt>Definition Classes</dt><dd>ArrowAssoc</dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.10.0)</i> Use <code><u>leftOfArrow<code> instead</code></u></code></p></dd></dl></div>
    </li><li name="scala.Predef.any2Ensuring#x" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="x:A"></a>
      <a id="x:Proxy[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="implicit shadowed deprecated" title="Deprecated: (Since version 2.10.0) Use resultOfEnsuring instead">x</span><span class="result">: <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit information</dt><dd>
            This member is added by an implicit conversion from <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to
            <span class="extype" name="scala.Predef.Ensuring">Ensuring</span>[<a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]] performed by method any2Ensuring in scala.Predef.
            
          </dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br />To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br /><div class="cmt"><pre>(proxy: Ensuring[Proxy[T]]).x</pre></div></dd><dt>Definition Classes</dt><dd>Ensuring</dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.10.0)</i> Use <code><u>resultOfEnsuring<code> instead</code></u></code></p></dd></dl></div>
    </li></ol>
            </div>
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.reactive.Signal">
              <h3>Inherited from <a href="Signal.html" class="extype" name="scala.reactive.Signal">Signal</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</h3>
            </div><div class="parent" name="scala.reactive.Reactive">
              <h3>Inherited from <a href="Reactive.html" class="extype" name="scala.reactive.Reactive">Reactive</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]</h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <a href="../package.html#AnyRef=Object" class="extmbr" name="scala.AnyRef">AnyRef</a></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        <div class="conversion" name="scala.reactive.Reactive.ReactiveOps">
              <h3>Inherited by implicit conversion ReactiveOps from
                <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to <a href="Reactive$$ReactiveOps.html" class="extype" name="scala.reactive.Reactive.ReactiveOps">ReactiveOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]
              </h3>
            </div><div class="conversion" name="scala.reactive.Signal.SignalOps">
              <h3>Inherited by implicit conversion SignalOps from
                <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to <a href="Signal$$SignalOps.html" class="extype" name="scala.reactive.Signal.SignalOps">SignalOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]
              </h3>
            </div><div class="conversion" name="scala.reactive.Signal.SignalOps">
              <h3>Inherited by implicit conversion SignalOps from
                <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to <a href="Signal$$SignalOps.html" class="extype" name="scala.reactive.Signal.SignalOps">SignalOps</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]
              </h3>
            </div><div class="conversion" name="scala.Predef.any2stringadd">
              <h3>Inherited by implicit conversion any2stringadd from
                <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to <span class="extype" name="scala.runtime.StringAdd">StringAdd</span>
              </h3>
            </div><div class="conversion" name="scala.Predef.any2stringfmt">
              <h3>Inherited by implicit conversion any2stringfmt from
                <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to <span class="extype" name="scala.runtime.StringFormat">StringFormat</span>
              </h3>
            </div><div class="conversion" name="scala.Predef.any2ArrowAssoc">
              <h3>Inherited by implicit conversion any2ArrowAssoc from
                <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to <span class="extype" name="scala.Predef.ArrowAssoc">ArrowAssoc</span>[<a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]]
              </h3>
            </div><div class="conversion" name="scala.Predef.any2Ensuring">
              <h3>Inherited by implicit conversion any2Ensuring from
                <a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>] to <span class="extype" name="scala.Predef.Ensuring">Ensuring</span>[<a href="" class="extype" name="scala.reactive.Signal.Proxy">Proxy</a>[<span class="extype" name="scala.reactive.Signal.Proxy.T">T</span>]]
              </h3>
            </div>
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
      <script defer="defer" type="text/javascript" id="jquery-js" src="../../lib/jquery.js"></script><script defer="defer" type="text/javascript" id="jquery-ui-js" src="../../lib/jquery-ui.js"></script><script defer="defer" type="text/javascript" id="tools-tooltip-js" src="../../lib/tools.tooltip.js"></script><script defer="defer" type="text/javascript" id="template-js" src="../../lib/template.js"></script>
    </body>
      </html>